Foliage Instancing
====================

The [Terrain3DInstancer](https://terrain3d.readthedocs.io/en/latest/api/class_terrain3dinstancer.html) can be used to optimally render hundreds of thousands of meshes in a single draw call. Meshes aren't limited to plants. They can be rocks, trees, pinecones, debris, or anything else.

The instancer uses Godot's [MultiMesh](https://docs.godotengine.org/en/stable/classes/class_multimesh.html) class. See this link for capabilities and engine tutorials.

**Table of Contents**
* [How To Use The Instancer](#how-to-use-the-instancer)
* [Limitations](#limitations)
* [Wind and Player Interaction](#wind-player-interaction)
* [Procedural Placement](#procedural-placement)
* [Importing From Other Tools](#importing-from-other-tools)


## How To Use The Instancer

### 1. Set Up A Mesh Asset

Click the Meshes tab in the Asset Dock and add a new mesh asset.

`Left click` an asset to select. `Right click` to edit. `Middle click` to reset or delete. You can only remove the last in the list, however you can replace their contents or reorder them by changing the ID.

```{image} images/asset_dock.png
:target: ../_images/asset_dock.png
```


Right click an asset to edit it in the Inspector.

```{image} images/mesh_asset.png
:target: ../_images/mesh_asset.png
```

Each mesh asset can be a generated texture card or a scene file (.tscn, .scn, .glb, .fbx). 

Changing the ID will reorder the assets in the list, allowing you to place one at the end for removal. It will also replace the meshes you've previously painted on the ground. See [No VRAM Overrun Protection](#no-vram-overrun-protection) below.

`Height Offset` allows you to adjust the origin point. For instance, if you have a 2 meter diameter rock with the origin point in the center, but you want all rocks to be sitting on the ground, you could enter 1 or 0.9 here and it will be placed near its edge.

If your mesh doesn't have a material attached, add or customize the override material as needed. If you are using a generated texture card, add your texture file to the albedo_texture slot in the material and enable transparency.

The generated texture card is a QuadMesh, which you can texture with a 2D texture of some plant.

### 2. Select The Mesh Asset

Click the desired mesh in the Asset Dock. This should also enable the foliage tool in the toolbar, but select it if not.

### 3. Adjust Placement Options

```{image} images/instancer_options.png
:target: ../_images/instancer_options.png
```

The instancer has many options for adjusting the height, scale, rotation, and color shifts while painting. There are options for fixed adjustments and random variances. For instance, using fixed_scale to increase all instances by 200%, and using random_scale to vary each by +/- 20%.

The paintable height offset is cummulative with the mesh asset height offset. This allows you to specify the default on the asset, and override it while painting.

Most of the options should be self explanatory.

Adjusting the vertex color requires `vertex_color_use_as_albedo` to be enabled in your material. The hue shift applies to the specified vertex color, which should have some saturation to see any effect. e.g. Hue shift on white will not be visible. Hue shift on red will.


### 4. Paint On The Ground

Paint instances on the terrain. You can remove instances by holding CTRL while painting.


## Limitations

There are some caveats and limitations built into the engine that you should be aware of.

### Simple Objects

Some 3D assets are complex objects with multiple, separate meshes, such as a tree trunk and leaves, a chest and lid, or a door frame and door. MultiMeshes support only one mesh. Our system scans the provided scene file and uses the first mesh it finds. If you give it a complex object with separate trunk and leaves, it will use only the trunk.

Either combine your complex objects into one (easy to do with the Join operation in Blender, while maintaining separate materials), or use another method of placement, such as AssetPlacer, Scatter, or manual placement.

If you do use multiple materials, make sure they are connected to the Mesh resource on import. We currently provide only a single material override.

### No Individual Culling

A MultiMesh renders all instances in one draw call, and it does not cull individual instances via frustum, occlusion, nor distance.

We mitigate this by generating multiple MultiMeshes, one per region, so that large blocks can be culled by frustum or occlusion. Later we'll likely expose distance culling, and will increase the number of MultiMeshes, reduce the size of each so they can be more finely culled by the engine.

### Limited LOD Support

MultiMeshes do work with the auto LODs generated by the import system. There are some bugs in the engine so you may find the meshes generated are sub par. If so, the only way to fix it is by disabling the auto LOD generation on that mesh and reimporting, which can be done with existing instances.

There is no facility within MultiMeshes to insert artist created LODs, stored as separate objects within your scene file. Currently, separate LODs are not supported. In the future we will generate additional MultiMeshes for these LODs. The whole LOD0 MultiMesh will be hidden, while LOD1 is shown, switching potentially thousands of instances at once. So this will only be effective once the smaller MultiMesh grid is implemented.

### No Collision

Multimeshes are generated and rendered on the GPU. The physics engine is on the CPU, and doesn't know anything about the placed instances. For now use this only for instances where collision is unnecessary like grass.

In the future, we will likely generate collision stored in your scene file. This will come as part of or after PR#278 Dynamic Collision.

### No Scene Transforms

Currently, the instancer uses the first Mesh resource it finds in the scene file and uses it as is. It ignores all transforms in the file, as they are not stored in the Mesh resource.

If you've built and imported your object with a non-zero transform, and have used the position, rotation, or scale in the scene file to fix your placement, then your instanced objects are going to have strange transforms. e.g. Your tree might be laying flat or extremely large or small.

Fix your object in blender by setting the origin point in the center of the volume, or at the bottom of the mesh. Move the mesh origin to (0, 0, 0). Ensure the scale is appropriate to real world units. Applying your transforms, so position and rotation are 0, and scale is 1. Be cognizant of your export and import settings. In the past, exporting via Blender FBX and importing into Godot produced a scene file where the mesh was scaled 0.01 and the parent node was scaled to 100. We use GLB/GLTF and don't have this issue. Ideally all nodes in your scene file have position and rotation at 0, and scale 1 just like in blender, and your mesh vertex positions are scaled to real world coordinates.

### No VRAM Overrun Protection

Godot currently has no protection against filling up your VRAM. Our instancer and asset dock allow you to swap meshes just by changing the mesh id. If you have hundreds of thousands of instances of a very simple texture card, and then swap that with a large mesh, you might instantly fill your VRAM as Godot attempts to draw hundreds of thousands of instances. Your console will fill with Vulkan errors complaining about running out of VRAM and you'll have to force Godot to quit and restart. Your system may also crash if you have flakey drivers or hardware.

## Wind, Player Interaction

These features can be implemented by having a wind shader or player interaction (grass flattening) shader in a ShaderMaterial attached to your mesh. We don't currently provide these shaders, but you can find both online. We may provide these shaders in the future. The instancer will use whatever material you've attached to the mesh or placed in the override slot, and the MultiMesh will automatically apply it to all instances.

## Procedural Placement

Placing instances via code is possible, but the API is a bit immature. See the documentation for [Terrain3DInstancer](https://terrain3d.readthedocs.io/en/latest/api/class_terrain3dinstancer.html).

One thing you must consider is if it makes sense to use this MultiMesh based instancer, or if it's more efficient to use a (self-implemented) particle shader.

**MultiMesh Pros & Cons:**
* Designed for hand painting and manual control
* API placement is possible, but a bit tricky
* Must manually paint, store, and load all transforms which is cumbersome for very large or procedural worlds
* More optimal for the same number of instances. Particle Shaders use MultiMeshes under the hood.

**Particle Shader Pros & Cons:**
* All automatic placement, no manual control
* No data stored, so the number of instances in memory can be significantly less. For very large or procedural worlds this would be much more efficient for loading and running.

## Importing From Other Tools

You can find a sample script that will import data from SimpleGrassTextured in `project/addons/terrain_3d/extras/import_sgt.gd`. SGT is another MultiMesh management tool, so the only data that we need from it are the transforms. This script serves as an example to learn how to use the API for procedural placement, as well as imports data from a third party app.

**To use it:**
1. Setup the mesh asset you wish to use.
1. Attach `import_sgt.gd` to your Terrain3D node.
1. Select your Terrain3D node.
1. At the top of the inspector, assign your SimpleGrassTextured node.
1. Select the desired mesh asset ID.
1. Click import and wait. Transfering 50,000 instances might take 30-60 seconds, so plan on waiting a while for the data to process. The slow aspect is processing each instance through GDScript. Your console will report when finished.
1. Clear the script from your Terrain3D node, and save your scene. The instance transforms are now stored in your Storage resource.


